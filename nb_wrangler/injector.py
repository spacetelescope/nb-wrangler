from pathlib import Path
import shutil
import re
from typing import Optional

from .logger import WranglerLoggable
from .repository import RepositoryManager
from .spec_manager import SpecManager
from .environment import WranglerEnvable
from . import utils
from .constants import DOCKER_BUILD_TIMEOUT


def get_injector(
    repo_manager: RepositoryManager, spec_manager: SpecManager
) -> "SpiInjector":
    """
    Factory method to create a subclass of a Injector which is tuned to
    configure an science-platform-images deployment based on a wrangler spec.

    Conceptually another subclass of Injector could be created to inject into
    a different image building system.
    """
    return SpiInjector(repo_manager, spec_manager)


class SpiInjector(WranglerLoggable, WranglerEnvable):
    """
    A class for interacting with a Science Platform Images (SPI) respository,
    which includes finding extra package requirements for the curated environment
    and also updating the repository deployment with the final package requirements
    generated by the spec.
    """

    _url = "https://github.com/spacetelescope/science-platform-images.git"

    def __init__(
        self,
        repo_manager: RepositoryManager,
        spec_manager: SpecManager,
    ):
        super().__init__()
        self.repo_manager = repo_manager
        self.spec_manager = spec_manager
        self.spi_path = Path(repo_manager.repos_dir) / self.repo_name
        self.deployment_name = self.spec_manager.deployment_name
        self.base_ingest_branch = "origin/main"
        self.ingest_dir = Path("nbw-spec-archive")
        self.archive_dir = Path("nbw-spec-archive")
        self.deployments_path = self.spi_path / "deployments"
        self.deployment_path = self.deployments_path / self.deployment_name
        self.environments_path = self.deployment_path / "environments"

    @property
    def url(self):
        return self.spec_manager.spi.get("repo") or self._url

    @property
    def repo_name(self):
        name = self.url.split("/")[-1]
        return name.split(".")[0]

    @property
    def spec_id(self):
        return self.spec_manager.spec_id

    @property
    def core_name(self):
        """Core name for both submission branch and archived spec,  minus file extension."

        Designed to sort repo spec archive simply into time order with the latest spec last
        and also to be directly traceable to the contents of the spec it names. This enables
        verifying that the image built and tagged corresponds to the submission.

        Based on: submission/current time, sanitized image name, prefix of spec sha256.
        """
        # Replace spaces, dots, etc. with "-".  Preserve case.
        ingestified = re.sub("[^0-9a-zA-Z-]", "-", self.spec_manager.image_name)
        return "-".join(["nbw", utils.hex_time(), ingestified, self.spec_id])

    @property
    def ingest_branch(self):
        """Name of branch that will be PR'ed for this --submit-for-build submission, based on core name."""
        return self.core_name

    @property
    def ingest_name(self) -> str:
        """Name of spec when added to wrangler nbw-spec-archive directory during --submit-for-build,
        traceable to ingest branch, image tag, and PR.
        """
        return self.core_name + ".yaml"

    @property
    def spi_injection_branch_name(self):
        """Name of branch for SPI injection of the spec, based on core name, when no branch
        is explicitly provided provided using --spi-branch."""
        return "spi-" + self.core_name.replace("nbw-", "")

    def submit_for_build(self):
        title = f"Wrangler spec for build {self.ingest_name}."
        message = f"""
Added wrangler spec {self.ingest_name} for {self.spec_manager.deployment_name}.
Hash: {self.spec_manager.sha256}
Description:
{self.spec_manager.description}
        """
        if not self.add_to_ingest(
            self.base_ingest_branch, self.ingest_name, self.ingest_branch, message
        ):
            return False
        if not self.push_and_pr(
            self.base_ingest_branch, self.ingest_branch, title, message
        ):
            return False
        return self.logger.info("Spec submission complete.")

    def add_to_ingest(
        self,
        base_ingest_branch: str,
        ingest_name: str,
        new_ingest_branch: str,
        message: str,
    ) -> bool | str:
        """During GitHub actions, copy the spec from the ingest directory
        to an archive location with a more recognizable name.
        """
        self.logger.info(
            f"Adding spec {ingest_name} to ingest directory {self.ingest_dir} on branch {new_ingest_branch}."
        )
        if not self.repo_manager.branch_repo(
            self.repo_name, new_ingest_branch, base_ingest_branch
        ):
            return False
        spec_dest = self.spi_path / self.ingest_dir
        spec_dest.mkdir(exist_ok=True, parents=True)
        self.copy_file(self.spec_manager.spec_file, spec_dest / ingest_name)
        if not self.repo_manager.git_add(self.repo_name, self.ingest_dir / ingest_name):
            return False
        if not self.repo_manager.git_commit(self.repo_name, message):
            return False
        return True

    def copy_file(self, fromfile: Path | str, tofile: Path | str) -> bool:
        fromfile, tofile = str(fromfile), str(tofile)
        self.logger.debug(f"Copying {fromfile} to {tofile}.")
        shutil.copy(fromfile, tofile)
        return True

    def push_and_pr(
        self, base_ingest_branch: str, new_ingest_branch: str, title: str, message: str
    ):
        self.logger.info(f"Pushing submission branch {new_ingest_branch}....")
        if not self.repo_manager.git_push(self.repo_name, new_ingest_branch):
            return False
        self.logger.info("Creating PR...")
        if not self.repo_manager.github_create_pr(
            self.repo_name, base_ingest_branch, title, message
        ):
            return False
        return True

    def set_wrangler_spec(self) -> bool:
        """Write out the wrangler environment spec with a generic name."""
        out_spec = self.environments_path / "nb-wrangler-spec.yaml"
        self.logger.info("Saving spec to SPI environments dir: ", out_spec)
        return self.spec_manager.save_spec(out_spec)

    def inject(self, kernel_name: str, env_exports: str) -> bool:
        """
        Performs a placeholder injection of the SPI.
        """
        self.logger.info(
            f"Initiating SPI injection into {self.spi_path} for {self.deployment_name} kernel {kernel_name}..."
        )
        if self.deployment_name != "wrangler":
            kernel_path = self.environments_path / kernel_name
            test_path = kernel_path / "tests"
            env_yml = kernel_path / f"{kernel_name}.yml"
            env_pip = kernel_path / f"{kernel_name}.pip"
            self._inject("test_imports", test_path / "imports")
            # self._inject("test_notebooks", self.test_path / "notebooks")
            self._inject("mamba_spec", env_yml)
            self._inject("pip_compiler_output", env_pip)
        self._inject(
            None, self.deployment_path / "MISSION_VERSION", self.spec_manager.moniker
        )
        self._inject(None, self.environments_path / "nbw-exports.sh", env_exports)
        self.spec_manager.save_spec_as(
            self.environments_path / "nbw-wrangler-spec.yaml", add_sha256=True
        )

        return self.logger.info("SPI injection complete.")

    def _inject(
        self, field: Optional[str], where: str | Path, literal: Optional[str] = None
    ) -> None:
        self.logger.info(f"Injecting field {field} to {where}")
        where = Path(where)
        if not where.parent.exists():
            self.logger.warning(
                f"Directory for '{where.parent}' does not exist, skipping injection."
            )
            return
        with where.open("w+") as f:
            if field:
                obj = self.spec_manager.get_output_data(field)
            elif literal is not None:
                obj = literal
            else:
                raise RuntimeError(
                    "Attempt to inject invalid field {field} or literal {literal} to {where}"
                )
            if isinstance(obj, dict):
                utils.get_yaml().dump(obj, f)
            elif isinstance(obj, list):
                f.write("\n".join(obj))
            elif isinstance(obj, str):
                f.write(obj)
            else:
                raise ValueError(f"Unsupported type {type(obj)} for field {field}")

    def branch(self, branch_name: str) -> bool:
        self.logger.info(f"Creating new branch {branch_name} in {self.repo_name}.")
        return self.repo_manager.git_create_branch(self.repo_name, branch_name)

    def add_injected_files(self) -> bool:
        self.logger.info(f"Adding injected files to git in {self.repo_name}.")
        return self.repo_manager.git_add(self.repo_name, "deployments")

    def commit(self, message: str) -> bool:
        self.logger.info(f"Committing changes in {self.repo_name}.")
        return self.repo_manager.git_commit(self.repo_name, message)

    def push(self, branch_name: str) -> bool:
        self.logger.info(f"Pushing branch {branch_name} to remote in {self.repo_name}.")
        return self.repo_manager.git_push(self.repo_name, branch_name)

    def create_pr(self, branch_name: str, message: str) -> bool:
        self.logger.info(
            f"Creating pull request for branch {branch_name} in {self.repo_name}."
        )
        title = f"nb-wrangler: Automated SPI injection for {self.spec_manager.spec_file.name}"
        return self.repo_manager.github_create_pr(
            self.repo_name, self.base_ingest_branch, title, message
        )

    def prune(self) -> bool:
        self.logger.info(f"Pruning Docker SPI images for {self.deployment_name}.")
        result = self.repo_manager.run(
            f"scripts/wrangler-prune {self.deployment_name}",
            check=False,
            cwd=self.spi_path,
            output_mode="uncaught",
        )
        return self.env_manager.handle_result(
            result,
            f"Failed to prune Docker for old {self.deployment_name} images: ",
            f"Pruned Docker to force rebuild of {self.deployment_name} images.",
        )

    def build(self) -> bool:
        self.logger.info(
            f"Building Docker image for {self.deployment_name} in {self.spi_path} with wrangler-build script."
        )
        result = self.repo_manager.run(
            f"scripts/wrangler-build {self.deployment_name}",
            check=False,
            cwd=self.spi_path,
            timeout=DOCKER_BUILD_TIMEOUT,
            output_mode="uncaught",
        )
        return self.env_manager.handle_result(
            result,
            f"Failed to build Docker image for {self.deployment_name} under {self.spi_path}: ",
            f"Built Docker image for {self.deployment_name} under {self.spi_path}.",
        )

    def get_spi_requirements(self, kind, glob_patterns: list[Path]) -> list[Path]:
        """Find extra mamba or pip requirements files required by SPI environments such as those
        included in the common/common-env directory. mamba packages are typically non-Python packages
        such as C libraries and compiles and install tools.  For Python packages,  using
        pip to install them is preferred.
        """
        spi_extra_requirements = []
        for pattern in glob_patterns:
            extras = Path(".").glob(str(pattern))
            for path in extras:
                spi_extra_requirements.append(path)
                self.logger.debug(
                    f"Found SPI {kind} requirements file {path} based on glob '{pattern}'"
                )
        self.logger.info(
            f"Found SPI extra {len(spi_extra_requirements)} {kind} requirements files."
        )
        return spi_extra_requirements

    def find_spi_pip_files(self) -> list[Path]:
        return self.get_spi_requirements(
            "pip",
            [
                self.deployments_path / "common/common-env/*.pip",
            ],
        )

    def find_spi_mamba_files(self) -> list[Path]:
        return self.get_spi_requirements(
            "mamba",
            [
                self.deployments_path / "common/common-env/*.conda",
                self.deployments_path / "common/common-env/*.mamba",
            ],
        )
